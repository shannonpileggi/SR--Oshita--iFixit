---
title: "Tables/Graphs for Article"
author: "Lisa Oshita"
date: "11/11/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
dir <- file.path(getwd(),"data")
out <- read.csv(file.path(dir, "answers_data.csv"))
list <- oshitar::variable_setup(out)
x <- list[[1]]
library(rms); library(survival); library(ggplot2); library(dplyr)
```

### Distribution of answer times

```{r}
x$Answered <- NA
x$Answered[x$answered == 1] <- "Answered"
x$Answered[x$answered == 0] <- "Unanswered"

ggplot(x, aes(x = time_until_answer, fill = Answered)) +
  geom_histogram(bins = 15, alpha = 0.5, position = "identity") + 
  guides(fill = guide_legend(title = NULL)) + 
  scale_x_continuous("Time (hrs)") + 
  scale_y_continuous("Number of Questions") + 
  theme(text = element_text(size = 25),
        axis.text = element_text(size = 15))

ggsave("times_dist.pdf", width = 8, height = 5)
```

### KM Curve

```{r}
surv_object <- Surv(x$time_until_answer, x$answered, type = "right")
KM <- survfit(surv_object ~ 1, conf.type = "log-log")
library(survminer)
# dashed line indicates the median survival time
ggsurvplot(KM, data = x, 
           risk.table = FALSE, 
           cumevents = FALSE, 
           conf.int = TRUE, conf.int.style = "step", 
           censor = FALSE,
           surv.median.line = "hv", 
           xlab = "Time (hours)", 
           xlim = c(0, 200), break.x.by = 20,
           ylim = c(0, 1), break.y.by = 0.1,
           surv.plot.height = 1, ggtheme = theme_bw(), 
           tables.height = 0.15, tables.theme = theme_cleantable(), fontsize = 2, na.rm = TRUE,
           legend = "none",
           font.x = 25, font.y = 25, font.tickslab = 15)

ggsave("kmcurve.pdf", width = 8, height = 5)
```

### Table of percentiles

```{r}
# 64% is largest available survival probability
quantiles <- quantile(KM, c(0.25, 0.50, 0.55, 0.58, 0.60, 0.64))$quantile 
quantilesdf <- data.frame(Percent = names(quantiles), 
                          Time = round(quantiles, 2))
colnames(quantilesdf) <- c(paste("Percent", "\n", "Answered", sep = ""), "Time (hours)")
rownames(quantilesdf) <- NULL

xtable::xtable(quantilesdf, label = "table:quantile")
```

### Model on full data 

```{r}
model <- rms::cph(Surv(time_until_answer, answered) ~ new_category + new_user + 
                   contain_unanswered + contain_answered + title_questionmark + 
                   text_contain_punct + text_all_lower + update + prior_effort + weekday +
                   sqrt(avg_tag_score) + rcs(sqrt(avg_tag_length), 4) + rcs(log10(text_length), 5) +
                   rcs(sqrt(device_length), 5) + rcs(sqrt(newline_ratio), 3), 
                   data = x, 
                   x = TRUE, y = TRUE, 
                   surv = TRUE)
model
```

### Univariate analysis results

```{r}
set.seed(444)
splitPlan <- vtreat::kWayCrossValidation(nrow(x), 5, NULL, NULL)

train1 <- x[splitPlan[[1]]$train, ]; test1 <- x[splitPlan[[1]]$app, ]
train2 <- x[splitPlan[[2]]$train, ]; test2 <- x[splitPlan[[2]]$app, ]
train3 <- x[splitPlan[[3]]$train, ]; test3 <- x[splitPlan[[3]]$app, ]
train4 <- x[splitPlan[[4]]$train, ]; test4 <- x[splitPlan[[4]]$app, ]
train5 <- x[splitPlan[[5]]$train, ]; test5 <- x[splitPlan[[5]]$app, ]

trains <- list(train1, train2, train3, train4, train5)
trains <- purrr::map(trains, ~as.data.frame(.))
tests <- list(test1, test2, test3, test4, test5)
tests <- purrr::map(tests, ~as.data.frame(.))
# ---------------------------------------------------------------------------------------
get_pvalue <- function(var) { 
  formula <- paste("Surv(time_until_answer, answered) ~ ", var, sep = "")
  model <- cph(stats::as.formula(formula), data = train1)
  df <- data.frame(variable = var, 
                   pvalue = unname(model$stats[5]))
  df <- df %>% arrange(pvalue)
  return(df)
}
```

```{r}
# categorical predictors 
categorical <- list("new_category", "new_user", "title_questionmark", 
                    "text_contain_punct", "weekday", "text_all_lower", 
                    "prior_effort", "update", "contain_unanswered", 
                    "contain_answered")
c_pvalue <- purrr::map_dfr(categorical, ~get_pvalue(.))

c_pvalue <- c_pvalue %>% arrange(pvalue)

xtable::xtable(c_pvalue, 
               caption = "Univariate analysis results for categorical predictors, 
                          ordered by increasing p-values", 
               label = "table:cresults")

# ---------------------------------------------------------------------------------------
# quantitative predictors + transformations 
text_length <- list("text_length", "sqrt(text_length)", "log10(text_length)")
txt_pvalue <- purrr::map_dfr(text_length, ~get_pvalue(.))

dev_length <- list("device_length", "sqrt(device_length)", "log10(device_length + 1)") 
dev_pvalue <- purrr::map_dfr(dev_length, ~get_pvalue(.))

newline <- list("newline_ratio", "sqrt(newline_ratio)", "log10(newline_ratio + 1)")
newline_pvalue <- purrr::map_dfr(newline, ~get_pvalue(.))

tag_length <- list("avg_tag_length", "sqrt(avg_tag_length)", "log10(avg_tag_length + 1)")
taglength_pvalue <- purrr::map_dfr(tag_length, ~get_pvalue(.))

tag_score <- list("avg_tag_score", "sqrt(avg_tag_score)", "log10(avg_tag_score + 1)")
tagscore_pvalue <- purrr::map_dfr(tag_score, ~get_pvalue(.))

univ_results <- rbind(txt_pvalue, dev_pvalue, newline_pvalue, taglength_pvalue, tagscore_pvalue)

univ_results <- univ_results %>% arrange(pvalue)

xtable::xtable(x = univ_results, 
               caption = "Univariate analysis results", 
               label = "table:qresults")

# ---------------------------------------------------------------------------------------
# choosing number of knots for splines
fit_splines <- function(var) { 
  none <- paste("Surv(time_until_answer, answered) ~ ", var, sep = "")
  model <- cph(stats::as.formula(none), data = train1)
  df <- data.frame(variable = "none", 
                   pvalue = unname(model$stats[5]), 
                   AIC = AIC(model, k = 2))
  
  f5 <- paste("Surv(time_until_answer, answered) ~ rcs(", var, ", 5)", sep = "")
  k5 <- cph(stats::as.formula(f5), data = train1)
  df5 <- data.frame(variable = "5 knots", 
                    pvalue = unname(k5$stats[5]), 
                    AIC = AIC(k5, k = 2))
  
  f4 <- paste("Surv(time_until_answer, answered) ~ rcs(", var, ", 4)", sep = "")
  k4 <- cph(stats::as.formula(f4), data = train1)
  df4 <- data.frame(variable = "4 knots", 
                    pvalue = unname(k4$stats[5]), 
                    AIC = AIC(k4, k = 2))
  
  f3 <- paste("Surv(time_until_answer, answered) ~ rcs(", var, ", 3)", sep = "")
  k3 <- cph(stats::as.formula(f3), data = train1)
  df3 <- data.frame(variable = "3 knots", 
                   pvalue = unname(k3$stats[5]), 
                   AIC = AIC(k3, k = 2))
  return(rbind(df, df5, df4, df3))
}
# ---------------------------------------------------------------------------------------
txt <- fit_splines("log10(text_length)") # 3 knots or none
newline <- fit_splines("sqrt(newline_ratio)") # 3 knots
tagscore <- fit_splines("sqrt(avg_tag_score)") # 5 knots or none 
device <- fit_splines("sqrt(device_length)") # 5 knots
taglength <- fit_splines("sqrt(avg_tag_length)") # 4 knots

splinedf <- rbind(txt, newline, tagscore, device, taglength)

xtable::xtable(splinedf, caption = "Determining the optimal number of splines for each predictor", label = "table:splines", digits = -16)
```

### Average CV metrics (Table 3 + 4) 

```{r}
# function for cross validation
crossval <- function(vars, train, test) {
  formula <- paste("Surv(time_until_answer, answered) ~ ", vars, sep = "")
  model <- rms::cph(as.formula(formula), data = train)
  
  train[["predictions"]] <- exp(predict(model, type = "lp"))
  metric <- rms::cph(Surv(time_until_answer, answered) ~ predictions, data = train)
  train_metrics <- data.frame(HR = exp(metric$coefficients), 
                              LR = metric$stats[3], 
                              pval = metric$stats[5],
                              R2 = metric$stats[8],
                              AIC = stats::AIC(metric, k = 2),
                              Dxy = metric$stats[9], 
                              Concordance = survConcordance(Surv(time_until_answer, answered) ~ predictions, data = train)$concordance)
  
  # predicting on test data
  test[["predictions"]] <- exp(predict(model, newdata = test, type = "lp"))
  
  # computing performance metrics 
  metric1 <- rms::cph(Surv(time_until_answer, answered) ~ predictions, data = test)
  test_metrics <- data.frame(HR = exp(metric1$coefficients), 
                             LR = metric1$stats[3], 
                             pval = metric1$stats[5], 
                             R2 = metric$stats[8],
                             AIC = stats::AIC(metric1, k = 2),
                             Dxy = metric1$stats[9], 
                             Concordance = survConcordance(Surv(time_until_answer, answered) ~ predictions, data = test)$concordance)
  
  # returns data frame with train/test metrics 
  statistics <- rbind(train_metrics, test_metrics)
  rownames(statistics) <- c("Training Data", "Test Data")
  return(statistics)
}
# ------------------------------------------
# function to average performance metrics, takes list of output from crossval
get_avgmetrics <- function(list) {
  avg <- rbind(train_avg = colMeans(purrr::map_df(1:length(list), ~rbind(list[[.]][1,]))), test_avg = colMeans(purrr::map_df(1:length(list), ~rbind(list[[.]][2,]))))
  return(avg)
}
# ------------------------------------------

vars1 <- "new_category + new_user + contain_unanswered + contain_answered + title_questionmark + text_contain_punct + text_all_lower + update + prior_effort + weekday + sqrt(avg_tag_score) + rcs(log10(text_length), 5) + rcs(sqrt(avg_tag_length), 4) + rcs(sqrt(device_length), 5) + rcs(sqrt(newline_ratio), 3)"

vars2 <- "new_category + new_user + contain_unanswered + contain_answered + title_questionmark + text_contain_punct + text_all_lower + update + prior_effort + weekday + log10(avg_tag_score + 1) + rcs(log10(text_length), 5) + rcs(log10(avg_tag_length + 1), 4) + rcs(log10(device_length + 1), 5) + rcs(log10(newline_ratio + 1), 3)"

cv_results1 <- purrr::map2(trains, tests, ~crossval(vars1, .x, .y))
cv_results2 <- purrr::map2(trains, tests, ~crossval(vars2, .x, .y))
avg_results2 <- get_avgmetrics(cv_results2)
avg_results2
avg_results1 <- get_avgmetrics(cv_results1)
avg_results1
xtable::xtable(avg_results1, caption = "Average performance metrics for training and test sets", label = "table:cv", digits = 4)
```

```{r}
avg_results2
```

# final model on full data

```{r}
# model statistics + parameters
# figure out how to get p-values 
parameterdf <- data.frame(variable = names(model$coefficients),
                          coefficients = round(unname(model$coefficients), 3))
parameterdf
xtable::xtable(parameterdf, caption = "Coefficients for predictors in the final model",
               label = "table:coefficients")
# ------------------------------------------
pvalues <- as.matrix(anova(model))[,3]
pvaluedf <- data.frame(variable = names(pvalues), 
                       pvalue = unname(pvalues))
xtable::xtable(pvaluedf, caption = "P-values for final model fit to the full data",
               label = "table:pvalues")

  
modelstats <- data.frame(statistic = names(model$stats), 
                         value = round(unname(model$stats), 3))
modelstats

# ------------------------------------------
# cross-validation metrics 
x$predictions <- exp(predict(model, type = "lp"))

metric <- rms::cph(Surv(time_until_answer, answered) ~ predictions, data = x)

final_metrics <- data.frame(HR = exp(metric$coefficients), 
                              LR = metric$stats[3], 
                              pval = metric$stats[5],
                              R2 = metric$stats[8],
                              AIC = stats::AIC(metric, k = 2),
                              Dxy = metric$stats[9], 
                              Concordance = survConcordance(Surv(time_until_answer, answered) ~ predictions, data = x)$concordance)
final_metrics
xtable::xtable(final_metrics, caption = "Performance metrics for model fit to the full data", label = "table:finalmetrics", digits = 4)

# ------------------------------------------
ph <- cox.zph(model)
ph_test <- data.frame(predictors = rownames(ph$table), ph$table)
rownames(ph_test) = NULL
ph_test <- ph_test %>% arrange(p) 
ph_test
```

```{r}
final_metrics
pvalues
anova(model)
```

### residuals

```{r}
x$mart <- residuals(model, type = "martingale")

ggplot(x, aes(x = avg_tag_score, y = mart)) + 
  geom_point() + 
  geom_smooth() + 
  ggtitle(paste("Martingale Residuals for average_tag_score")) + 
  scale_x_continuous("Average Tag Score (square root)") 

plotm <- function(var) {
  ggplot(x, aes(x = x[[var]], y = mart)) + 
    geom_point() + 
    geom_smooth() + 
    ggtitle(paste("Martingale Residuals for", var)) + 
    scale_x_continuous(var)
}

x$sqrt_length <- sqrt(x$avg_tag_length)
x$sqrt_score <- sqrt(x$avg_tag_score)

plotm("sqrt_score")
plotm("text_length")
plotm("device_length")
plotm("sqrt_length")
plotm("newline_ratio")
```